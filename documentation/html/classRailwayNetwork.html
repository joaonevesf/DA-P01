<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Railway Network Analysis Tool: RailwayNetwork Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Railway Network Analysis Tool
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classRailwayNetwork-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">RailwayNetwork Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="RailwayNetwork_8h_source.html">RailwayNetwork.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a46f5f12d0e5e404e1c2ade4521282554"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRailwayNetwork.html#a46f5f12d0e5e404e1c2ade4521282554">addStation</a> (std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; station)</td></tr>
<tr class="separator:a46f5f12d0e5e404e1c2ade4521282554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65054a6d76bcc7fb235d3da34e620467"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRailwayNetwork.html#a65054a6d76bcc7fb235d3da34e620467">addTrack</a> (std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; station_src, std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; station_dest, std::string service, double w, int cost)</td></tr>
<tr class="separator:a65054a6d76bcc7fb235d3da34e620467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab775af7394f0f730cdbaefe22f2f77d8"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt;, <a class="el" href="structStationHash.html">StationHash</a>, <a class="el" href="structStationHashEquality.html">StationHashEquality</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRailwayNetwork.html#ab775af7394f0f730cdbaefe22f2f77d8">getStationSet</a> () const</td></tr>
<tr class="separator:ab775af7394f0f730cdbaefe22f2f77d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79da9abbce4b05f0ecec458059f408ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRailwayNetwork.html#a79da9abbce4b05f0ecec458059f408ea">setPathBFS</a> (<a class="el" href="classStation.html">Station</a> *src, <a class="el" href="classStation.html">Station</a> *dest, double flow_min_limit)</td></tr>
<tr class="separator:a79da9abbce4b05f0ecec458059f408ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca59a083b084a6efbb1955ee67d4dbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRailwayNetwork.html#a7ca59a083b084a6efbb1955ee67d4dbd">findAugmentingPathBFS</a> (const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;station_src, const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;station_dest, bool ignoreIsActive)</td></tr>
<tr class="separator:a7ca59a083b084a6efbb1955ee67d4dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c90463038c43b3efdda790a04a0eb8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRailwayNetwork.html#ac3c90463038c43b3efdda790a04a0eb8">findAugmentingPathDijkstra</a> (const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;station_src, const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;station_dest)</td></tr>
<tr class="separator:ac3c90463038c43b3efdda790a04a0eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64b30792ced7608720f26addbbdd2b5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRailwayNetwork.html#ae64b30792ced7608720f26addbbdd2b5">edmondsKarp</a> (const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;station_src, const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;station_dest, bool isIgnoreIsActive)</td></tr>
<tr class="separator:ae64b30792ced7608720f26addbbdd2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b9a8d2d37bcf631a8c3dcd23477d9d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRailwayNetwork.html#ab5b9a8d2d37bcf631a8c3dcd23477d9d">maxTrainsTo</a> (const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;dest)</td></tr>
<tr class="separator:ab5b9a8d2d37bcf631a8c3dcd23477d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d18c2fe1a92ebd4a5ff5927903fb64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRailwayNetwork.html#ad4d18c2fe1a92ebd4a5ff5927903fb64">connectSourceNodesTo</a> (<a class="el" href="classStation.html">Station</a> *mock_source)</td></tr>
<tr class="separator:ad4d18c2fe1a92ebd4a5ff5927903fb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993657bdcab6e390a4d7374bf88bd411"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRailwayNetwork.html#a993657bdcab6e390a4d7374bf88bd411">connectSinkNodesTo</a> (std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; mock_sink)</td></tr>
<tr class="separator:a993657bdcab6e390a4d7374bf88bd411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6561d62fe8f7555082918df0b8e166e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRailwayNetwork.html#a6561d62fe8f7555082918df0b8e166e7">deactivateTrack</a> (const std::shared_ptr&lt; <a class="el" href="classTrack.html">Track</a> &gt; &amp;track)</td></tr>
<tr class="separator:a6561d62fe8f7555082918df0b8e166e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7e2b4358df2fe75dfb83cdce7cda63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRailwayNetwork.html#a4d7e2b4358df2fe75dfb83cdce7cda63">deactivateStation</a> (const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;station)</td></tr>
<tr class="separator:a4d7e2b4358df2fe75dfb83cdce7cda63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1ea4a52964853b4b6cd4d4de4118b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRailwayNetwork.html#ace1ea4a52964853b4b6cd4d4de4118b6">undoLastDeletion</a> ()</td></tr>
<tr class="separator:ace1ea4a52964853b4b6cd4d4de4118b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b58bcf4794d6dfc9614b6a2bf80fe2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRailwayNetwork.html#ae7b58bcf4794d6dfc9614b6a2bf80fe2">undoAllDeletions</a> ()</td></tr>
<tr class="separator:ae7b58bcf4794d6dfc9614b6a2bf80fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be7fff60bde2a91593d44a0b860f946"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRailwayNetwork.html#a8be7fff60bde2a91593d44a0b860f946">clearNetworkUtils</a> ()</td></tr>
<tr class="separator:a8be7fff60bde2a91593d44a0b860f946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8370e6591149c3ff52f12f33c9580398"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRailwayNetwork.html#a8370e6591149c3ff52f12f33c9580398">findMaxFlowMinCost</a> (const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;src, const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;dest, int &amp;flow_result)</td></tr>
<tr class="separator:a8370e6591149c3ff52f12f33c9580398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954d38aa8894e03a4d8f69cb5705fdbb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRailwayNetwork.html#a954d38aa8894e03a4d8f69cb5705fdbb">testAndVisitDijkstra</a> (std::queue&lt; <a class="el" href="classStation.html">Station</a> * &gt; &amp;queue, std::shared_ptr&lt; <a class="el" href="classTrack.html">Track</a> &gt; track, <a class="el" href="classStation.html">Station</a> *v, double residual, bool isDest)</td></tr>
<tr class="separator:a954d38aa8894e03a4d8f69cb5705fdbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46cfaaee1c567e5dd737fdaf7c69f3b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRailwayNetwork.html#a46cfaaee1c567e5dd737fdaf7c69f3b4">resetFlow</a> ()</td></tr>
<tr class="separator:a46cfaaee1c567e5dd737fdaf7c69f3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad023091aa41c91284330eae3e1e78fe1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRailwayNetwork.html#ad023091aa41c91284330eae3e1e78fe1">mostAffectedStations</a> (int k)</td></tr>
<tr class="separator:ad023091aa41c91284330eae3e1e78fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b0a4ac735ed151e1e9abec87979492"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::pair&lt; std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt;, std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRailwayNetwork.html#a03b0a4ac735ed151e1e9abec87979492">mostUsedPairsStations</a> ()</td></tr>
<tr class="separator:a03b0a4ac735ed151e1e9abec87979492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab726771cb5d71d0c76cf4eebe51ce25d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, std::pair&lt; double, double &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRailwayNetwork.html#ab726771cb5d71d0c76cf4eebe51ce25d">topRegionsByNeeds</a> (int k, bool isDistrict)</td></tr>
<tr class="separator:ab726771cb5d71d0c76cf4eebe51ce25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aaf8d62dfafe080109bc4e48a754ff884"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRailwayNetwork.html#aaf8d62dfafe080109bc4e48a754ff884">testAndVisit</a> (std::queue&lt; std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &gt; &amp;queue, const std::shared_ptr&lt; <a class="el" href="classTrack.html">Track</a> &gt; &amp;track, const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;station, double residual, bool ignoreIsActive)</td></tr>
<tr class="separator:aaf8d62dfafe080109bc4e48a754ff884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7278eb7354e5cc73cd80adf2b2ad07"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRailwayNetwork.html#abb7278eb7354e5cc73cd80adf2b2ad07">findMinResidual</a> (const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;station_src, std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; station_dest)</td></tr>
<tr class="separator:abb7278eb7354e5cc73cd80adf2b2ad07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45686bc2f4a1789177e644516e0fd16"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRailwayNetwork.html#aa45686bc2f4a1789177e644516e0fd16">updatePath</a> (const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;station_src, std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; station_dest, double minRes)</td></tr>
<tr class="separator:aa45686bc2f4a1789177e644516e0fd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a989d1f0c6a668344820a38402da6d93f"><td class="memItemLeft" align="right" valign="top"><a id="a989d1f0c6a668344820a38402da6d93f" name="a989d1f0c6a668344820a38402da6d93f"></a>
std::unordered_set&lt; std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt;, <a class="el" href="structStationHash.html">StationHash</a>, <a class="el" href="structStationHashEquality.html">StationHashEquality</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>stationSet</b></td></tr>
<tr class="separator:a989d1f0c6a668344820a38402da6d93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470a0ec05ce3c7ba03c533fe672d5953"><td class="memItemLeft" align="right" valign="top"><a id="a470a0ec05ce3c7ba03c533fe672d5953" name="a470a0ec05ce3c7ba03c533fe672d5953"></a>
std::stack&lt; std::shared_ptr&lt; <a class="el" href="classTrack.html">Track</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>inactiveTracks</b></td></tr>
<tr class="separator:a470a0ec05ce3c7ba03c533fe672d5953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4bf2d11880f91bdcc6ea79cddf8a01"><td class="memItemLeft" align="right" valign="top"><a id="a3c4bf2d11880f91bdcc6ea79cddf8a01" name="a3c4bf2d11880f91bdcc6ea79cddf8a01"></a>
std::stack&lt; std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>inactiveStations</b></td></tr>
<tr class="separator:a3c4bf2d11880f91bdcc6ea79cddf8a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468b2828f6a2b11c4739d5fde39c021b"><td class="memItemLeft" align="right" valign="top"><a id="a468b2828f6a2b11c4739d5fde39c021b" name="a468b2828f6a2b11c4739d5fde39c021b"></a>
std::stack&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>deletionRecord</b></td></tr>
<tr class="separator:a468b2828f6a2b11c4739d5fde39c021b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Classe que irá guardar todas as informações e métodos para manipular o grafo que representa a rede rodoviária carregada pelo utilizador </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a46f5f12d0e5e404e1c2ade4521282554" name="a46f5f12d0e5e404e1c2ade4521282554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f5f12d0e5e404e1c2ade4521282554">&#9670;&#160;</a></span>addStation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RailwayNetwork::addStation </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt;&#160;</td>
          <td class="paramname"><em>station</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simplesmente insere um apontador para uma estação na tabela de dispersão que tem as estações </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">station</td><td>Apontador para a estação a adicionar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Retorna sempre verdadeiro a não ser que a inserção falhe </dd></dl>

</div>
</div>
<a id="a65054a6d76bcc7fb235d3da34e620467" name="a65054a6d76bcc7fb235d3da34e620467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65054a6d76bcc7fb235d3da34e620467">&#9670;&#160;</a></span>addTrack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RailwayNetwork::addTrack </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt;&#160;</td>
          <td class="paramname"><em>station_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt;&#160;</td>
          <td class="paramname"><em>station_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adiciona uma linha no vetor adj do station_src, assim como também adiciona essa mesma linha ao vetor incoming do station_dest </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">station_src</td><td></td></tr>
    <tr><td class="paramname">station_dest</td><td></td></tr>
    <tr><td class="paramname">service</td><td>"ALFA PENDULAR" ou "STANDARD" </td></tr>
    <tr><td class="paramname">w</td><td>A capacidade dessa linha </td></tr>
    <tr><td class="paramname">cost</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Falso caso os apontadores sejam NULL. Caso contrário, retorna verdadeiro. </dd></dl>

</div>
</div>
<a id="a8be7fff60bde2a91593d44a0b860f946" name="a8be7fff60bde2a91593d44a0b860f946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be7fff60bde2a91593d44a0b860f946">&#9670;&#160;</a></span>clearNetworkUtils()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RailwayNetwork::clearNetworkUtils </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Repõe os valores padrão dos boleanos utilitários de todas as estações e tracks no grafo Complexidade temporal: O(V * N + E), onde V é o número de estações, N é o tamanho do vetor e E é o número de arestas </p>

</div>
</div>
<a id="a993657bdcab6e390a4d7374bf88bd411" name="a993657bdcab6e390a4d7374bf88bd411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a993657bdcab6e390a4d7374bf88bd411">&#9670;&#160;</a></span>connectSinkNodesTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RailwayNetwork::connectSinkNodesTo </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt;&#160;</td>
          <td class="paramname"><em>mock_sink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Conecta o mock_sink a todas as estações que não têm arestas outgoing Isto é usado para os algoritmos de cálculo de fluxo máximo onde queremos Complexidade temporal: O(V), onde V é o número de estações </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mock_sink</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4d18c2fe1a92ebd4a5ff5927903fb64" name="ad4d18c2fe1a92ebd4a5ff5927903fb64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d18c2fe1a92ebd4a5ff5927903fb64">&#9670;&#160;</a></span>connectSourceNodesTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RailwayNetwork::connectSourceNodesTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classStation.html">Station</a> *&#160;</td>
          <td class="paramname"><em>mock_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Conecta o mock_source a todas as estações que não têm arestas incoming ou às que têm apenas uma aresta incoming que é reverse de uma das arestas outgoing dessa estação Isto é usado para os algoritmos de cálculo de fluxo máximo onde queremos considerar as várias sources ao mesmo tempo Complexidade temporal: O(|V| + |E|), no pior dos casos </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mock_source</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d7e2b4358df2fe75dfb83cdce7cda63" name="a4d7e2b4358df2fe75dfb83cdce7cda63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7e2b4358df2fe75dfb83cdce7cda63">&#9670;&#160;</a></span>deactivateStation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RailwayNetwork::deactivateStation </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>station</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Desativa uma track, adiciona essa track à stack inactiveStations e adiciona ?? Dá throw a uma exceção std::logic_error caso station seja nullptr Complexidade temporal: O(1) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">station</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6561d62fe8f7555082918df0b8e166e7" name="a6561d62fe8f7555082918df0b8e166e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6561d62fe8f7555082918df0b8e166e7">&#9670;&#160;</a></span>deactivateTrack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RailwayNetwork::deactivateTrack </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classTrack.html">Track</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>track</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Desativa uma track, adiciona essa track à stack inactiveTracks e adiciona ?? Dá throw a uma exceção std::logic_error caso track seja nullptr Complexidade temporal: O(1) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">track</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae64b30792ced7608720f26addbbdd2b5" name="ae64b30792ced7608720f26addbbdd2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64b30792ced7608720f26addbbdd2b5">&#9670;&#160;</a></span>edmondsKarp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double RailwayNetwork::edmondsKarp </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>station_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>station_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isIgnoreIsActive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Aplicação sem muitas alterações do algoritmo do edmonds karp para encontrar o fluxo máximo entre uma estação de chegada e outra de partida Complexidade temporal: O(VE^2) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">station_src</td><td></td></tr>
    <tr><td class="paramname">station_dest</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>O resultado do fluxo máximo </dd></dl>

</div>
</div>
<a id="a7ca59a083b084a6efbb1955ee67d4dbd" name="a7ca59a083b084a6efbb1955ee67d4dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca59a083b084a6efbb1955ee67d4dbd">&#9670;&#160;</a></span>findAugmentingPathBFS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RailwayNetwork::findAugmentingPathBFS </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>station_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>station_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreIsActive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uma variação do BFS para encontrar o caminho mais curto de peso 1 entre um source e um destino É maioritariamente utilizada como função de pathfinding no algoritmo do edmonds karp Complexidade Temporal: O(|V| + |E|) (pior dos casos) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">station_src</td><td></td></tr>
    <tr><td class="paramname">station_dest</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Verdadeiro se encontrar um caminho por onde é possível aumentar fluxo entre uma partida e uma chegada. Falso, caso contrário </dd></dl>

</div>
</div>
<a id="ac3c90463038c43b3efdda790a04a0eb8" name="ac3c90463038c43b3efdda790a04a0eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c90463038c43b3efdda790a04a0eb8">&#9670;&#160;</a></span>findAugmentingPathDijkstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RailwayNetwork::findAugmentingPathDijkstra </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>station_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>station_dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uma variação do Dijkstra Single Source Shortest Path para um determinado destino. É utilizado para encontrar um caminho por onde se pode aumentar fluxo no contexto de contrar o fluxo máximo pelo custo mínimo Complexidade temporal: O(Elog(V)) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">station_src</td><td></td></tr>
    <tr><td class="paramname">station_dest</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Verdadeiro se encontrar um caminho por onde é possível aumentar fluxo entre uma partida e uma chegada. Falso, caso contrário </dd></dl>

</div>
</div>
<a id="a8370e6591149c3ff52f12f33c9580398" name="a8370e6591149c3ff52f12f33c9580398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8370e6591149c3ff52f12f33c9580398">&#9670;&#160;</a></span>findMaxFlowMinCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RailwayNetwork::findMaxFlowMinCost </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>flow_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encontra o fluxo máximo com o menor custo possível com uma variante do Edmonds-Karp que em vez de usar BFS, usa uma variante do Dijkstra Complexidade temporal: O((Elog(V)) * E), onde V é o número de estações e E é o número de arestas </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td></td></tr>
    <tr><td class="paramname">dest</td><td></td></tr>
    <tr><td class="paramname">flow_result</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cost </dd></dl>

</div>
</div>
<a id="abb7278eb7354e5cc73cd80adf2b2ad07" name="abb7278eb7354e5cc73cd80adf2b2ad07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7278eb7354e5cc73cd80adf2b2ad07">&#9670;&#160;</a></span>findMinResidual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double RailwayNetwork::findMinResidual </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>station_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt;&#160;</td>
          <td class="paramname"><em>station_dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Percorre um caminho encontrado pelo @augmentingPathBFS por onde foi atualizado e encontra o mínimo de capacidade restante entre todas as arestas entre o destino e partida Complexidade Temporal: O(|A|), sendo |A| o nº de arestas do caminho entre um destino e uma partida </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">station_src</td><td></td></tr>
    <tr><td class="paramname">station_dest</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ab775af7394f0f730cdbaefe22f2f77d8" name="ab775af7394f0f730cdbaefe22f2f77d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab775af7394f0f730cdbaefe22f2f77d8">&#9670;&#160;</a></span>getStationSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt;, <a class="el" href="structStationHash.html">StationHash</a>, <a class="el" href="structStationHashEquality.html">StationHashEquality</a> &gt; RailwayNetwork::getStationSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Esta função não tem nada de especial, é um getter normal </p>

</div>
</div>
<a id="ab5b9a8d2d37bcf631a8c3dcd23477d9d" name="ab5b9a8d2d37bcf631a8c3dcd23477d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b9a8d2d37bcf631a8c3dcd23477d9d">&#9670;&#160;</a></span>maxTrainsTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double RailwayNetwork::maxTrainsTo </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cria uma mock source e liga-as a todas as outras sources individuais e corre o edmonds karp começando no mock source para encontrar o número máximo de comboios que pode chegar ao dest Complexidade temporal: O(EV^2), no pior dos casos </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>O resultado do fluxo máximo entre o mock source e o destino </dd></dl>

</div>
</div>
<a id="ad023091aa41c91284330eae3e1e78fe1" name="ad023091aa41c91284330eae3e1e78fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad023091aa41c91284330eae3e1e78fe1">&#9670;&#160;</a></span>mostAffectedStations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &gt; RailwayNetwork::mostAffectedStations </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determina quais estações têm mais fluxo perdido Complexidade temporal: O(VE^2), onde V é o número de estações e E é o número de arestas </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vetor com as k estações mais afetadas </dd></dl>

</div>
</div>
<a id="a03b0a4ac735ed151e1e9abec87979492" name="a03b0a4ac735ed151e1e9abec87979492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b0a4ac735ed151e1e9abec87979492">&#9670;&#160;</a></span>mostUsedPairsStations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::pair&lt; std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt;, std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &gt; &gt; RailwayNetwork::mostUsedPairsStations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determina os pares de estações pelos quais passam mais fluxo Complexidade temporal: O(2^V * VE^2), onde V é o número de estações e E é o número de arestas </p><dl class="section return"><dt>Returns</dt><dd>set com os pares de estações pelos quais passam mais fluxo </dd></dl>

</div>
</div>
<a id="a46cfaaee1c567e5dd737fdaf7c69f3b4" name="a46cfaaee1c567e5dd737fdaf7c69f3b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46cfaaee1c567e5dd737fdaf7c69f3b4">&#9670;&#160;</a></span>resetFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RailwayNetwork::resetFlow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atribui o valor zero ao flow de todas as arestas do grafo Complexidade temporal: O(V + E), onde V é o número de estações e E é o número de arestas </p>

</div>
</div>
<a id="a79da9abbce4b05f0ecec458059f408ea" name="a79da9abbce4b05f0ecec458059f408ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79da9abbce4b05f0ecec458059f408ea">&#9670;&#160;</a></span>setPathBFS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RailwayNetwork::setPathBFS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classStation.html">Station</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classStation.html">Station</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>flow_min_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utilizado para percorrer o caminho entre uma partida e uma chegada e colocar todos os pais de cada aresta no atributo multiple_parents_path de cada nó. Esta função é util quando se pretende reconstruir o caminho pelos pais de cada nó Complexidade temporal: O(|V| + |E|), no pior dos casos o src e o dest estão entre os nós todos </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td></td></tr>
    <tr><td class="paramname">dest</td><td></td></tr>
    <tr><td class="paramname">flow_min_limit</td><td>O número que serve como limite numérico para determinar se o BFS ignora ou não uma linha mediante o seu fluxo </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf8d62dfafe080109bc4e48a754ff884" name="aaf8d62dfafe080109bc4e48a754ff884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8d62dfafe080109bc4e48a754ff884">&#9670;&#160;</a></span>testAndVisit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void RailwayNetwork::testAndVisit </td>
          <td>(</td>
          <td class="paramtype">std::queue&lt; std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classTrack.html">Track</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>track</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>station</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreIsActive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Função utilizada no contexto de encontrar um agumenting path no problema do fluxo máximo para verificar se se pode adicionar fluxo por uma aresta ou pelo reverso dela ou não Complexidade Temporal: O(1) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Será uma fila para onde o testAndVisit irá carregar as estações que estarão no caminho </td></tr>
    <tr><td class="paramname">track</td><td></td></tr>
    <tr><td class="paramname">station</td><td></td></tr>
    <tr><td class="paramname">residual</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a954d38aa8894e03a4d8f69cb5705fdbb" name="a954d38aa8894e03a4d8f69cb5705fdbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a954d38aa8894e03a4d8f69cb5705fdbb">&#9670;&#160;</a></span>testAndVisitDijkstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RailwayNetwork::testAndVisitDijkstra </td>
          <td>(</td>
          <td class="paramtype">std::queue&lt; <a class="el" href="classStation.html">Station</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classTrack.html">Track</a> &gt;&#160;</td>
          <td class="paramname"><em>track</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classStation.html">Station</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isDest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serve para ser utilizado no findAugmentingDijkstraPath para verificar se um determinado caminho é possível de ser adicionado á priority queue utilizada pelo dijkstra </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td></td></tr>
    <tr><td class="paramname">track</td><td></td></tr>
    <tr><td class="paramname">v</td><td></td></tr>
    <tr><td class="paramname">residual</td><td></td></tr>
    <tr><td class="paramname">isDest</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false quando não podemos passar fluxo pela estação, true caso contrário </dd></dl>

</div>
</div>
<a id="ab726771cb5d71d0c76cf4eebe51ce25d" name="ab726771cb5d71d0c76cf4eebe51ce25d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab726771cb5d71d0c76cf4eebe51ce25d">&#9670;&#160;</a></span>topRegionsByNeeds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::string, std::pair&lt; double, double &gt; &gt; &gt; RailwayNetwork::topRegionsByNeeds </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isDistrict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determina os concelhos ou distritos (dependendo do valor do parâmetro isDistrict) com a maior razão fluxo por capacidade, em que o fluxo é a soma dos fluxos das arestas nessa região e a capacidade é a soma das capacidades das arestas nessa região Complexidade temporal: O(VE^2), onde V é o número de estações e E é o número de arestas </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td></td></tr>
    <tr><td class="paramname">isDistrict</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vetor com o nome das regiões com maior razão fluxo por capacidade e os respetivos fluxos e capacidades </dd></dl>

</div>
</div>
<a id="ae7b58bcf4794d6dfc9614b6a2bf80fe2" name="ae7b58bcf4794d6dfc9614b6a2bf80fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b58bcf4794d6dfc9614b6a2bf80fe2">&#9670;&#160;</a></span>undoAllDeletions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RailwayNetwork::undoAllDeletions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reativa todos os elementos desativados Complexidade temporal: O(V + E), onde V é o número de estações desativadas e E é o número de tracks desativadas </p>

</div>
</div>
<a id="ace1ea4a52964853b4b6cd4d4de4118b6" name="ace1ea4a52964853b4b6cd4d4de4118b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace1ea4a52964853b4b6cd4d4de4118b6">&#9670;&#160;</a></span>undoLastDeletion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RailwayNetwork::undoLastDeletion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reativa o último elemento desativado se este existir Complexidade temporal: O(1) </p>

</div>
</div>
<a id="aa45686bc2f4a1789177e644516e0fd16" name="aa45686bc2f4a1789177e644516e0fd16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45686bc2f4a1789177e644516e0fd16">&#9670;&#160;</a></span>updatePath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int RailwayNetwork::updatePath </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>station_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classStation.html">Station</a> &gt;&#160;</td>
          <td class="paramname"><em>station_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deve ser corrida apenas depois do @findMinResidual e do @findAugmentingPathBFS Serve para pegar no resultado do findMinResidual e atualizar o fluxo em cada aresta Complexidade temporal: O(|E|) no pior dos casos </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">station_src</td><td></td></tr>
    <tr><td class="paramname">station_dest</td><td></td></tr>
    <tr><td class="paramname">minRes</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/tomaspalma/DA-P01/include/<a class="el" href="RailwayNetwork_8h_source.html">RailwayNetwork.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
